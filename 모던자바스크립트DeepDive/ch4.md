[모던 자바스크립트 Deep Dive]
[4장] 변수

---

### 1. 변수란 무엇인가? 왜 필요한가?

- 자바스크립트 엔진의 계산

  - 리터럴과 연산자, 표현식 파싱

  - 메모리 상의 임의의 위치(메모리 주소)에 기억(저장)

  - CPU는 그 값을 읽어 연산 수행하고 메모리 상의 임의의 위치에 저장

  - 결과를 재사용 시 메모리 주소를 통해 값에 직접 접근 X

    - 치명적인 오류를 야기할 가능성이 있음

  - 변수를 통해 값에 간접 접근 O

    - 코드가 실행 될 때마다 메모리 상의 임의의 위치에 저장해서 변수로 활용하여 안전성 높임

- 컴퓨터

  - 메모리 셀의 크기 단위로 데이터를 저장, 읽음

  - 모든 데이터를 2진수로 저장

- 메모리

  - 데이터를 저장할 수 있는 메모리 셀의 집합체

  - 메모리 셀 하나의 크기는 1 바이트 (8비트)

  - 각 셀은 고유의 메모리 주소를 가짐

- 메모리 주소

  - 메모리 공간의 위치를 나타냄

  - 0 ~ 메모리 크기 만큼 정수로 표현됨

  - ex. 0x00000000 ~ 0xFFFFFFFF

- 변수

  - 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 식별 이름

  - 하나의 값을 저장하고 참고하는 메커니즘

  - 컴파일러, 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행됨

    - 변수를 통해 안전하게 값에 접근 가능

- 할당(대입, 저장)

  - 변수에 값을 저장하는 것

- 참조

  - 변수에 저장된 값을 읽어들이는 것

---

### 2. 식별자

- 식별자(변수 이름) == 메모리 주소 이름

  - 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름

  - 메모리 주소, 그와의 매핑 관계를 메모리에 저장(기억)

  - 변수, 함수, 클래스 등

  - 선언을 통해 자바스크립트 엔진에 식별자의 존재를 알림

---

### 3. 변수 선언

- 변수 선언

  - 값을 저장하기 위한 메모리 공간을 확보, 변수 이름과 확보된 메모리 공간의 주소를 연결, 값을 저장할 수 있게 준비하는 것 (변수 생성)

  - 변수 선언으로 확보된 메모리 공간은 확보 해제 전까지 보호됨

  - 선언 단계, 초기화 단계

- 키워드

  - 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어

  - var, let, const

    - var 키워드의 단점?

      - 블록 레벨 스코프를 미지원, 함수 레벨 스코프를 지원

      - 의도치 않게 전역 변수가 선언될 수 있음

      - let, const는 이의 단점을 보완하기 위해 도입

  - 자바스크립트 엔진에 의해 undefined 값이 암묵적 할당되어 초기화됨

- undefined

  - 자바스크립트에서 제공되는 원시 타입의 값

- 실행 컨텍스트

  - 모든 식별자가 저장됨

  - 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공, 코드의 실행 결과를 실제로 관리하는 영역

  - 자바스크립트 엔진은 실행 컨텍스트를 통해 식별자, 스코프를 관리

  - 모든 식별자와 값은 키 / 값 형식의 객체로 등록됨

  - ReferenceError : 자바스크립트 엔진이 등록된 식별자를 찾지 못할 때 발생

---

### 4. 변수 선언의 실행 시점과 변수 호이스팅

- 실행이 선언보다 앞섰을 때 참조 에러가 아닌 undefined가 출력되는 이유?

  - 변수 선언이 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문

  - 런타임

    - 소스코드가 한 줄씩 순차적으로 실행되는 시점

  - 소스코드의 평가 과정에서 자바스크립트 엔진이 모든 선언문을 찾아내 먼저 실행

  - 평가 과정이 끝나면 모든 선언문을 제외하고 런타임을 가짐

- 변수 호이스팅

  - 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

---

### 5. 값의 할당

- 할당 연산자 '=' 사용

- 변수 선언은 런타임 이전에 먼저 실행되고 할당은 런타임에 실행됨

---

### 6. 값의 재할당

- 재할당

  - 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것

  - 첫 할당도 재할당임 (기본적으로 undefined로 초기화)

  - var, let으로 선언한 변수는 재할당 가능

- 상수

  - 한번 정해지면 변하지 않는 값

  - const로 선언한 변수는 재할당 불가능

- 가비지 콜렉터

  - 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리(어떤 식별자도 참조하지 않음)를 해제하는 기능(메모리 누수 방지)

  - 자바스크립트는 가비지 콜렉터를 내장하는 매니지드 언어

---

### 7. 식별자 네이밍 규칙

- 네이밍 규칙

  - 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호($)를 포함 가능

  - 단, 식별자는 특수문자를 제외한 문자, 언더스코어(\_), 달러 기호($)로 시작해야 함 (숫자 미허용)

  - 예약어는 식별자로 사용 불가능

- 예약어

  - 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어

  - await, break, case, catch, class, const, continue, debugger, default, delete, do, else, enum, export, extends, false, finally, for, function, if, implements, import, in, instanceof, interace, let, new, null, package, private, protected, public, return, super, static, switch, this, throw, true, try, typeof, var, void, while, with, yield

- 네이밍 컨벤션 (대소문자 구별, 의미 명확)

  - 하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 명명 규칙

  - 카멜 케이스(camelCase) \*

  - 스네이크 케이스(snake_case)

  - 파스칼 케이스(PascalCase) \*

  - 헝가리언 케이스(typeHungarianCase)

---
